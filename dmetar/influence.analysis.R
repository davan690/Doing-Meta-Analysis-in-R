#' Influence Diagnostics Plot
#'
#' Conducts an influence analysis of meta-analysis results generated by \code{\link[meta]{meta}} functions
#' and produces influence diagnostic plots.
#'
#' @usage InfluenceAnalysis(x, random = FALSE, subplot.heights = c(30,18),
#'     subplot.widths = c(30,30), forest.lims = 'default',
#'     return.separate.plots = FALSE, text.scale = 1)
#'
#' @param x An object of class \code{meta}, generated by the \code{metabin}, \code{metagen},
#' \code{metacont}, \code{metacor}, \code{metainc}, or \code{metaprop} function.
#' @param random Logical. Should the random-effects model be used to generate the influence diagnostics?
#' Uses the \code{method.tau} specified in the \code{meta} object if one
#' of \code{"DL", "HE", "SJ", "ML", "REML", "EB", "HS"} or \code{"GENQ"} (to ensure compatibility with
#' the \code{\link[metafor]{metafor}} package). Otherwise, the DerSimonian-Laird
#' (\code{"DL"}; DerSimonian & Laird, 1986) estimator is used. \code{FALSE} by default.
#' @param subplot.heights Concatenated array of two numerics. Specifies the heights of the
#' first (first number) and second (second number) row of the overall results plot generated by the function.
#' Default is \code{c(30,18)}.
#' @param subplot.widths Concatenated array of two numerics. Specifies the widths of the
#' first (first number) and second (second number) column of the overall results plot generated by the function.
#' Default is \code{c(30,30)}.
#' @param forest.lims Concatenated array of two numerics. Specifies the x-axis limits of the forest plots
#' generated by the function. Use \code{"default"} if standard settings should be used (this is the default).
#' @param return.separate.plots Logical. Should the influence plots be returned as seperate plots in lieue
#' of returning them in one overall plot? Additionally returns a dataframe \code{Data} containing
#' the data used for plotting. If set to \code{TRUE}, the ouput of the function must be saved in a variable;
#' specific plots can then be accessed by selecting the plot element and using \code{plot()}.
#' @param text.scale Positive numeric. Scaling factor for the text geoms used in the plot. Values <1 shrink the
#' text, while values >1 increase the text size. Default is \code{1}.
#'
#' @details
#' The function conducts an influence analysis using the "Leave-One-Out" paradigm internally
#' and produces four diagnostic plots. These plots may be used to determine which study or effect size
#' may have an excessive influence on the overall results of a meta-analysis and/or contribute substantially to
#' the between-study heterogeneity in an analysis. This may be used for outlier detection and to test
#' the robustness of the overall results found in an analysis. Four plots are produced,
#' left to right, top to bottom:
#' \itemize{
#' \item \strong{Baujat Plot}: Baujat et al. (2002) proposed a plot to evaluate heterogeneity patterns in
#' a meta-analysis. The x-axis of the Baujat plot shows the overall heterogeneity contribution of each effect size
#' while the y-axis shows the influence of each effect size on the pooled result. The \code{\link[meta]{metainf}}
#' function is called internally to produce data used for plotting. Effect sizes or studies with high values
#' on both the x and y-axis may be considered to be influential cases; effect sizes or studies
#' with high heterogeneity contribution (x-axis) and low influence on the overall results can be outliers
#' which might be deleted to reduce the amount of between-study heterogeneity.
#' \item \strong{Influence Characteristics}: Produces plots for several influence analysis diagnostics
#' proposed by Viechtbauer & Cheung (2010). Data for plotting are generated by an internal call
#' to \code{\link[metafor]{influence.rma.uni}}. Effect sizes/studies determined to be influential cases
#' using the "rules of thumb" described in Viechtbauer & Cheung (2010) are plotted in red. For further
#' details, see the documentation of the \code{\link[metafor]{influence.rma.uni}} function.
#' \item \strong{Forest Plot for the Leave-One-Out Analysis, sorted by effect size}: This forest plot
#' displays the effect size and \eqn{I^2}-heterogeneity when omitting one of the \eqn{k} studies each time.
#' The plot is sorted by effect size to determine which studies or effect sizes particularly
#' affect the overall effect size. Results are generated by an internal call to \code{\link[meta]{metainf}}.
#' \item \strong{Forest Plot for the Leave-One-Out Analysis, sorted by \eqn{I^2}}: see above; results are sorted
#' by \eqn{I^2} to determine the study for which exclusion results in the greatest reduction of heterogeneity.
#'}
#'
#' @references Harrer, M., Cuijpers, P., Furukawa, T.A, & Ebert, D. D. (2019).
#' \emph{Doing Meta-Analysis in R: A Hands-on Guide}. DOI: 10.5281/zenodo.2551803. \href{https://bookdown.org/MathiasHarrer/Doing_Meta_Analysis_in_R/influenceanalyses.html}{Chapter 6.3}
#'
#' DerSimonian R. & Laird N. (1986), Meta-analysis in clinical trials. \emph{Controlled Clinical Trials, 7}, 177–188.
#'
#' Viechtbauer, W., & Cheung, M. W.-L. (2010). Outlier and influence diagnostics for meta-analysis. \emph{Research Synthesis Methods, 1}, 112–125.
#'
#' @author Mathias Harrer & David Daniel Ebert
#'
#' @return If \code{return.separate.plots} is set to \code{TRUE}, a \code{list} object containing the
#' following objects is returned (if results are saved to a variable):
#' \itemize{
#' \item \code{BaujatPlot}: The Baujat plot
#' \item \code{InfluenceCharacteristics}: The Viechtbauer-Cheung influence characteristics plot
#' \item \code{ForestEffectSize}: The forest plot sorted by effect size
#' \item \code{ForestI2}: The forest plot sorted by between-study heterogeneity
#' \item \code{Data}: A \code{data.frame} containing the data used for plotting.
#'}
#'
#' @import ggplot2 ggrepel forcats dplyr grid
#' @importFrom  gridExtra grid.arrange arrangeGrob
#' @importFrom metafor rma.uni influence.rma.uni
#' @importFrom meta metainf
#' @importFrom graphics abline axis lines mtext par plot points rect segments text
#' @importFrom stats as.formula hat influence ks.test optimize pbinom pchisq pf pnorm pt punif qchisq qf qnorm qt reformulate reorder setNames uniroot
#'
#' @export InfluenceAnalysis
#'
#' @seealso \code{\link[metafor]{influence.rma.uni}}, \code{\link[meta]{metainf}}, \code{\link[meta]{baujat}}
#'
#' @examples
#' # Load 'ThirdWave' data
#' data(ThirdWave)
#'
#' # Create 'meta' meta-analysis object
#' suppressPackageStartupMessages(library(meta))
#' meta = metagen(TE, seTE, studlab = paste(ThirdWave$Author), data=ThirdWave)
#'
#' # Return seperate plots
#' InfluenceAnalysis(meta, subplot.heights = c(30,24), text.scale=0.5)


### Influence Analysis function for fixed-effect-model meta-analyses

InfluenceAnalysis = function(x, random = FALSE, subplot.heights = c(30, 18), subplot.widths = c(30, 30),
    forest.lims = "default", return.separate.plots = FALSE, text.scale = 1) {

    # Validate
    x = x
    if (class(x)[1] %in% c("meta", "metabin", "metagen", "metacont", "metacor", "metainc", "metaprop")) {

    } else {

        stop("Object 'x' must be of class 'meta', 'metabin', 'metagen', 'metacont', 'metacor', 'metainc', or 'metaprop'")
    }

    n.studies = x$k
    TE = x$TE
    seTE = x$seTE
    random = random

    if (random %in% c(TRUE, FALSE)) {


    } else {

        stop("'random' must be set to either TRUE or FALSE.")
    }

    forest.lims = forest.lims

    if (forest.lims[1] == "default" | (class(forest.lims[1]) == "numeric" & class(forest.lims[2]) == "numeric")) {

    } else {
        stop("'forest.lims' must either be 'default' or two concatenated numerics for ymin and ymax.")
    }

    return.seperate.plots = return.separate.plots

    if (return.seperate.plots %in% c(TRUE, FALSE)) {


    } else {

        stop("'return.separate.plots' must be set to either TRUE or FALSE.")
    }


    heights = subplot.heights
    if (class(heights[1]) == "numeric" & class(heights[2]) == "numeric") {

    } else {
        stop("'subplot.heights' must be two concatenated numerics.")
    }


    widths = subplot.widths
    if (class(widths[1]) == "numeric" & class(widths[2]) == "numeric") {

    } else {
        stop("'widths' must be two concatenated numerics.")
    }

    text.scale = text.scale
    if (text.scale > 0) {

    } else {
        stop("'text.scale' must be a single number greater 0.")
    }

    if (length(unique(x$studlab)) != length(x$studlab)) {
        stop("'Study labels in the 'meta' object must be unique.")
    }

    ########################################
    cat("[===============")
    ########################################

    if (random == FALSE) {
        method.rma = "FE"
        method.meta = "fixed"
    } else {
        if (x$method.tau %in% c("DL", "HE", "SJ", "ML", "REML", "EB", "HS", "GENQ")) {
            method.rma = x$method.tau
        } else {
            method.rma = "DL"
            cat("Tau estimator is unkown to metafor::rma; DerSimonian-Laird ('DL') estimator used.")
        }
        method.meta = "random"
    }

    # Perform Meta-Analysis using metafor, get influence results
    res = metafor::rma.uni(yi = TE, sei = seTE, measure = "GEN", data = x, method = method.rma, slab = studlab)
    metafor.inf = influence(res)
    # Recode inf
    metafor.inf$is.infl = ifelse(metafor.inf$is.infl == TRUE, "yes", "no")
    cheungviechtdata = cbind(study = substr(rownames(as.data.frame(metafor.inf$inf)), 1, 3), as.data.frame(metafor.inf$inf), is.infl = metafor.inf$is.infl)
    rownames(cheungviechtdata) = NULL

    if (length(unique(cheungviechtdata$study)) < length(cheungviechtdata$study)) {

        i = 3

        while (length(unique(cheungviechtdata$study)) < length(cheungviechtdata$study)) {

            i = i + 1
            cheungviechtdata$study = substr(rownames(metafor.inf$inf), 1, i)

        }


    }

    ########################################
    cat("===============")
    ########################################

    scalefun = function(x) sprintf("%.1f", x)

    cheungviechtdata = as.data.frame(cheungviechtdata)

    # Generate plots
    rstudent.plot = ggplot2::ggplot(cheungviechtdata, aes(y = rstudent, x = study, color = is.infl, group = 1)) +
        geom_line(color = "black") + geom_point(size = 2) + scale_color_manual(values = c("blue", "red")) +
        theme_minimal() + theme(axis.title.x = element_blank(), legend.position = "none", axis.text.x = element_text(angle = 45,
        size = 5), axis.title.y = element_text(size = 7), axis.text.y = element_text(size = 5)) + ylab("Stand. Residual") +
        scale_y_continuous(labels = scalefun)

    dffits.thresh = 3 * sqrt(metafor.inf$p/(metafor.inf$k - metafor.inf$p))
    dffits.plot = ggplot2::ggplot(cheungviechtdata, aes(y = dffits, x = study, color = is.infl, group = 1)) +
        geom_line(color = "black") + geom_point(size = 2) + scale_color_manual(values = c("blue", "red")) +
        theme_minimal() + theme(axis.title.x = element_blank(), legend.position = "none", axis.text.x = element_text(angle = 45,
        size = 5), axis.title.y = element_text(size = 7), axis.text.y = element_text(size = 5)) + ylab("DFFITS") +
        scale_y_continuous(labels = scalefun)
    # geom_hline(yintercept = dffits.thresh, linetype='dashed', color='black')

    cook.d.plot = ggplot2::ggplot(cheungviechtdata, aes(y = cook.d, x = study, color = is.infl, group = 1)) +
        geom_line(color = "black") + geom_point(size = 2) + scale_color_manual(values = c("blue", "red")) +
        theme_minimal() + theme(axis.title.x = element_blank(), legend.position = "none", axis.text.x = element_text(angle = 45,
        size = 5), axis.title.y = element_text(size = 7), axis.text.y = element_text(size = 5)) + ylab("Cook's Distance") +
        scale_y_continuous(labels = scalefun)

    cov.r.plot = ggplot2::ggplot(cheungviechtdata, aes(y = cov.r, x = study, color = is.infl, group = 1)) +
        geom_line(color = "black") + geom_point(size = 2) + scale_color_manual(values = c("blue", "red")) +
        theme_minimal() + theme(axis.title.x = element_blank(), legend.position = "none", axis.text.x = element_text(angle = 45,
        size = 5), axis.title.y = element_text(size = 7), axis.text.y = element_text(size = 5)) + ylab("Covariance Ratio") +
        scale_y_continuous(labels = scalefun)

    tau2.del.plot = ggplot2::ggplot(cheungviechtdata, aes(y = tau2.del, x = study, color = is.infl, group = 1)) +
        geom_line(color = "black") + geom_point(size = 2) + scale_color_manual(values = c("blue", "red")) +
        theme_minimal() + theme(axis.title.x = element_blank(), legend.position = "none", axis.text.x = element_text(angle = 45,
        size = 5), axis.title.y = element_text(size = 7), axis.text.y = element_text(size = 5)) + ylab("tau-squared (L-0-0)") +
        scale_y_continuous(labels = scalefun)

    QE.del.plot = ggplot2::ggplot(cheungviechtdata, aes(y = QE.del, x = study, color = is.infl, group = 1)) +
        geom_line(color = "black") + geom_point(size = 2) + scale_color_manual(values = c("blue", "red")) +
        theme_minimal() + theme(axis.title.x = element_blank(), legend.position = "none", axis.text.x = element_text(angle = 45,
        size = 5), axis.title.y = element_text(size = 7), axis.text.y = element_text(size = 5)) + ylab("Q (L-0-0)") +
        scale_y_continuous(labels = scalefun)

    hat.thresh = 3 * (metafor.inf$p/metafor.inf$k)
    hat.plot = ggplot2::ggplot(cheungviechtdata, aes(y = hat, x = study, color = is.infl, group = 1)) + geom_line(color = "black") +
        geom_point(size = 2) + scale_color_manual(values = c("blue", "red")) + theme_minimal() + theme(axis.title.x = element_blank(),
        legend.position = "none", axis.text.x = element_text(angle = 45, size = 5), axis.title.y = element_text(size = 7),
        axis.text.y = element_text(size = 5)) + ylab("hat") + scale_y_continuous(labels = scalefun)
    # geom_hline(yintercept = hat.thresh, linetype='dashed', color='black')

    weight.plot = ggplot2::ggplot(cheungviechtdata, aes(y = weight, x = study, color = is.infl, group = 1)) +
        geom_line(color = "black") + geom_point(size = 2) + scale_color_manual(values = c("blue", "red")) +
        theme_minimal() + theme(axis.title.x = element_blank(), legend.position = "none", axis.text.x = element_text(angle = 45,
        size = 5), axis.title.y = element_text(size = 7), axis.text.y = element_text(size = 5)) + ylab("weight") +
        scale_y_continuous(labels = scalefun)

    rma.influence.plot = arrangeGrob(rstudent.plot, dffits.plot, cook.d.plot, cov.r.plot, tau2.del.plot, QE.del.plot,
        hat.plot, weight.plot, ncol = 2)

    # Perform Influence Analysis on meta object, generate forests
    meta.inf = meta::metainf(x, pooled = method.meta)

    if (x$sm %in% c("RR", "OR", "IRR")) {

        effect = x$sm
        n.studies = n.studies

        # Create Sortdat data set for sorting
        sortdat = data.frame(studlab = meta.inf$studlab, mean = exp(meta.inf$TE), lower = exp(meta.inf$lower),
            upper = exp(meta.inf$upper), i2 = meta.inf$I2)
        sortdat2 = sortdat[1:(nrow(sortdat) - 2), ]
        lastline = sortdat[nrow(sortdat), ]

        # Change summary label
        if (random == TRUE) {
            lastline[1] = "Random-Effects Model"
        } else {
            lastline[1] = "Fixed-Effect Model"
        }

        for (i in 2:4) {
            lastline[i] = format(round(lastline[i], 2), nsmall = 2)
        }

        # Sort
        sortdat.es = sortdat2[order(sortdat2$mean), ]
        sortdat.es = sortdat.es %>% mutate(studlab = forcats::fct_reorder(studlab, -mean))
        sortdat.i2 = sortdat2[order(sortdat2$i2), ]
        sortdat.i2 = sortdat.i2 %>% mutate(studlab = forcats::fct_reorder(studlab, -i2))

        # Generate Forest Plots
        if (forest.lims[1] == "default") {
            min = 0.5
            max = round(max(sortdat.es$mean) + 2, 2)
        } else {
            min = forest.lims[1]
            max = forest.lims[2]
        }

        ########################################
        cat("===============")
        ########################################

        forest.es = ggplot(sortdat.es, aes(x = studlab, y = mean, ymin = lower, ymax = upper)) + geom_pointrange() +
            geom_text(aes(label = paste(format(round(mean, 2), nsmall = 2), " [", format(round(lower, 2),
                nsmall = 2), ";", format(round(upper, 2), nsmall = 2), "] ", "; I2=", format(round(i2, 2),
                nsmall = 2), sep = ""), y = Inf), hjust = "inward", size = 2 * text.scale) + geom_hline(yintercept = 1,
            color = "blue") + ylab(paste(effect, " (", as.character(lastline$studlab), ")", sep = "")) + ggtitle("Sorted by Effect Size") +
            coord_flip() + theme_minimal() + theme(axis.title.y = element_blank(), axis.title.x = element_text(color = "black",
            size = 12, face = "bold"), axis.text.y = element_text(color = "black", size = 9 * text.scale),
            plot.title = element_text(face = "bold", hjust = 0.5), axis.line.x = element_line(color = "black"),
            axis.ticks.x = element_line(color = "black"), axis.text.x = element_text(color = "black", size = 9 *
                text.scale)) + scale_y_continuous(trans = "log2", limits = c(min, max))
        forest.i2 = ggplot(sortdat.i2, aes(x = studlab, y = mean, ymin = lower, ymax = upper)) + geom_pointrange() +
            geom_text(aes(label = paste("I2=", format(round(i2, 2), nsmall = 2), "; ", format(round(mean,
                2), nsmall = 2), " [", format(round(lower, 2), nsmall = 2), ";", format(round(upper, 2), nsmall = 2),
                "] ", sep = ""), y = Inf), hjust = "inward", size = 2 * text.scale) + geom_hline(yintercept = 1,
            color = "blue") + ylab(paste(effect, " (", as.character(lastline$studlab), ")", sep = "")) + ggtitle("Sorted by I-squared") +
            coord_flip() + theme_minimal() + theme(axis.title.y = element_blank(), axis.title.x = element_text(color = "black",
            size = 12, face = "bold"), axis.text.y = element_text(color = "black", size = 9 * text.scale),
            plot.title = element_text(face = "bold", hjust = 0.5), axis.line.x = element_line(color = "black"),
            axis.ticks.x = element_line(color = "black"), axis.text.x = element_text(color = "black", size = 9 *
                text.scale)) + scale_y_continuous(trans = "log2", limits = c(min, max))

    } else {

        # Create Sortdat data set for sorting
        sortdat = data.frame(studlab = meta.inf$studlab, mean = meta.inf$TE, lower = meta.inf$lower, upper = meta.inf$upper,
            i2 = meta.inf$I2)
        sortdat2 = sortdat[1:(nrow(sortdat) - 2), ]
        lastline = sortdat[nrow(sortdat), ]

        # Change summary label
        if (random == TRUE) {
            lastline[1] = "Random-Effects Model"
        } else {
            lastline[1] = "Fixed-Effect Model"
        }

        for (i in 2:4) {
            lastline[i] = format(round(lastline[i], 2), nsmall = 2)
        }

        # Sort
        sortdat.es = sortdat2[order(sortdat2$mean), ]
        sortdat.es = sortdat.es %>% mutate(studlab = forcats::fct_reorder(studlab, -mean))
        sortdat.i2 = sortdat2[order(sortdat2$i2), ]
        sortdat.i2 = sortdat.i2 %>% mutate(studlab = forcats::fct_reorder(studlab, -i2))

        # Generate Forest Plots
        if (forest.lims[1] == "default") {
            min = round(min(sortdat.es$lower) - 0.1, 2)
            max = round(max(sortdat.es$upper) + 0.3, 2)
        } else {
            min = forest.lims[1]
            max = forest.lims[2]
        }

        ########################################
        cat("===============")
        ########################################

        forest.es = ggplot(sortdat.es, aes(x = studlab, y = mean, ymin = lower, ymax = upper)) + geom_pointrange() +
            geom_text(aes(label = paste(format(round(mean, 2), nsmall = 2), " [", format(round(lower, 2),
                nsmall = 2), ";", format(round(upper, 2), nsmall = 2), "] ", "; I2=", format(round(i2, 2),
                nsmall = 2), sep = ""), y = Inf), hjust = "inward", size = 2 * text.scale) + geom_hline(yintercept = 0,
            color = "blue") + ylim(min, max) + ylab(paste("Effect Size (", as.character(lastline$studlab),
            ")", sep = "")) + ggtitle("Sorted by Effect Size") + coord_flip() + theme_minimal() + theme(axis.title.y = element_blank(),
            axis.title.x = element_text(color = "black", size = 12, face = "bold"), axis.text.y = element_text(color = "black",
                size = 9 * text.scale), plot.title = element_text(face = "bold", hjust = 0.5), axis.line.x = element_line(color = "black"),
            axis.ticks.x = element_line(color = "black"), axis.text.x = element_text(color = "black", size = 9 *
                text.scale))
        forest.i2 = ggplot(sortdat.i2, aes(x = studlab, y = mean, ymin = lower, ymax = upper)) + geom_pointrange() +
            geom_text(aes(label = paste("I2=", format(round(i2, 2), nsmall = 2), "; ", format(round(mean,
                2), nsmall = 2), " [", format(round(lower, 2), nsmall = 2), ";", format(round(upper, 2), nsmall = 2),
                "] ", sep = ""), y = Inf), hjust = "inward", size = 2) + geom_hline(yintercept = 0, color = "blue") +
            ylim(min, max) + ylab(paste("Effect Size (", as.character(lastline$studlab), ")", sep = "")) +
            ggtitle("Sorted by I2") + coord_flip() + theme_minimal() + theme(axis.title.y = element_blank(),
            axis.title.x = element_text(color = "black", size = 12, face = "bold"), axis.text.y = element_text(color = "black",
                size = 9 * text.scale), plot.title = element_text(face = "bold", hjust = 0.5), axis.line.x = element_line(color = "black"),
            axis.ticks.x = element_line(color = "black"), axis.text.x = element_text(color = "black", size = 9 *
                text.scale))

    }


    # Generate baujat plot Define baujat.silent
    baujat.silent = function(x, yscale = 1, xlim, ylim, ...) {

        TE = x$TE
        seTE = x$seTE
        TE.fixed = metagen(TE, seTE, exclude = x$exclude)$TE.fixed
        k = x$k
        studlab = x$studlab
        SE = x$seTE

        m.inf = metainf(x, pooled = "fixed")
        TE.inf = m.inf$TE[1:length(TE)]
        seTE.inf = m.inf$seTE[1:length(TE)]

        ys = (TE.inf - TE.fixed)^2/seTE.inf^2
        ys = ys * yscale

        xs = (TE - TE.fixed)^2/seTE^2

        if (!is.null(x$exclude))
            xs[x$exclude] = 0



        res = data.frame(studlab = studlab, x = xs, y = ys, se = SE)


        return(res)
    }

    ########################################
    cat("===============")
    ########################################

    bjt = baujat.silent(x)

    BaujatPlot = ggplot(bjt, aes(x = x, y = y)) + geom_point(aes(size = (1/se)), color = "blue", alpha = 0.75) +
        geom_rug(color = "lightgray", alpha = 0.5) + theme(legend.position = "none") + xlab("Overall hetereogeneity contribution") +
        ylab("Influence on pooled result") + geom_label_repel(label = bjt$studlab, color = "black", size = 1.5 *
        text.scale, alpha = 0.7)


    # Return
    if (return.seperate.plots == FALSE) {


        # Combine
        title = textGrob("Influence Diagnostics", gp = gpar(fontface = "bold"))
        suppressWarnings(suppressMessages(gridExtra::grid.arrange(BaujatPlot, rma.influence.plot, forest.es,
            forest.i2, nrow = 2, ncol = 2, widths = widths, heights = heights, top = title)))

        ########################################
        cat("===============] DONE")
        ########################################


    } else {

        # Prepare data for return
        return.data = cbind(sortdat2, cheungviechtdata[, 2:ncol(cheungviechtdata)], HetContrib = bjt$x, InfluenceEffectSize = bjt$y)

        ########################################
        cat("===============] DONE \n")
        ########################################

        if (x$sm %in% c("RR", "OR", "IRR")) {

            colnames(return.data)[1:2] = c("Author", effect)

        } else {

            colnames(return.data)[1:2] = c("Author", "effect")
        }


        cat("When 'return.separate.plots' is set to 'TRUE', save the results of the influence_analysis function to an object and then access each plot with the '$' operator. Then use the object as an input to 'plot()'.")

        suppressWarnings(suppressMessages(invisible(list(BaujatPlot = BaujatPlot, InfluenceCharacteristics = rma.influence.plot,
            ForestEffectSize = forest.es, ForestI2 = forest.i2, Data = return.data))))
    }

}


